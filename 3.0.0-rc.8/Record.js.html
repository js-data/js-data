<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>js-data Source: Record.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/googlecode.min.css">
	<link type="text/css" rel="stylesheet" href="styles/site.jsdata.css">
  <style>
    a {
      text-decoration: none !important;
    }
    .hljs {
      padding: 0;
      background: none;
    }
    #toc {
      position: fixed;
      margin-top: 62px;
      overflow-y: scroll;
      max-height: 85%;
    }
    #toc .toc-list-group-item {
      display: block;
    }
    #toc .toc-list-group-item.active {
      font-weight: bold;
    }
    #toc .toc-list-group-item span.toc-h3 {
      font-weight: bold;
    }
    #main {
      padding-left: 4%;
    }
    article h4.name, article dt.name {
      font-family: monospace;
      font-weight: bold;
    }
    .code-panel.panel pre {
      background-color: #FBFBFB;
      border-color: #E6E5E5;
    }
    .page-title {
      color: #000;
    }
    span.param-type a {
      padding: 3px 5px;
    }
    span.param-type a:hover {
      background-color: #158CBA;
      color: #fff;
    }
    .panel ul {
      padding-left: 0;
    }
    .panel ul li {
      list-style-type: none;
    }
    .tonic {
      padding-left: 20px;
    }
  </style>

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html"><img class="branding-logo" src="https://raw.githubusercontent.com/js-data/js-data/master/js-data-64.png"
		alt="logo"/>js-data</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="query.html">query</a></li><li><a href="utils.html">utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-js-data.html">js-data</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Collection.html">Collection</a></li><li><a href="Component.html">Component</a></li><li><a href="Container.html">Container</a></li><li><a href="DataStore.html">DataStore</a></li><li><a href="LinkedCollection.html">LinkedCollection</a></li><li><a href="Mapper.html">Mapper</a></li><li><a href="Query_.html">Query</a></li><li><a href="Record.html">Record</a></li><li><a href="Schema.html">Schema</a></li><li><a href="Settable.html">Settable</a></li><li><a href="SimpleStore.html">SimpleStore</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Collection.html#event:add">Collection#event:add</a></li><li><a href="Collection.html#event:change">Collection#event:change</a></li><li><a href="Collection.html#event:remove">Collection#event:remove</a></li><li><a href="Container.html#event:afterCreate">Container#event:afterCreate</a></li><li><a href="Container.html#event:afterCreateMany">Container#event:afterCreateMany</a></li><li><a href="Container.html#event:afterDestroy">Container#event:afterDestroy</a></li><li><a href="Container.html#event:afterDestroyAll">Container#event:afterDestroyAll</a></li><li><a href="Container.html#event:afterFind">Container#event:afterFind</a></li><li><a href="Container.html#event:afterFindAll">Container#event:afterFindAll</a></li><li><a href="Container.html#event:afterUpdate">Container#event:afterUpdate</a></li><li><a href="Container.html#event:afterUpdateAll">Container#event:afterUpdateAll</a></li><li><a href="Container.html#event:afterUpdateMany">Container#event:afterUpdateMany</a></li><li><a href="Container.html#event:beforeCreate">Container#event:beforeCreate</a></li><li><a href="Container.html#event:beforeCreateMany">Container#event:beforeCreateMany</a></li><li><a href="Container.html#event:beforeDestroy">Container#event:beforeDestroy</a></li><li><a href="Container.html#event:beforeDestroyAll">Container#event:beforeDestroyAll</a></li><li><a href="Container.html#event:beforeFind">Container#event:beforeFind</a></li><li><a href="Container.html#event:beforeFindAll">Container#event:beforeFindAll</a></li><li><a href="Container.html#event:beforeUpdate">Container#event:beforeUpdate</a></li><li><a href="Container.html#event:beforeUpdateAll">Container#event:beforeUpdateAll</a></li><li><a href="Container.html#event:beforeUpdateMany">Container#event:beforeUpdateMany</a></li><li><a href="DataStore.html#event:add">DataStore#event:add</a></li><li><a href="DataStore.html#event:afterCreate">DataStore#event:afterCreate</a></li><li><a href="DataStore.html#event:afterCreateMany">DataStore#event:afterCreateMany</a></li><li><a href="DataStore.html#event:afterDestroy">DataStore#event:afterDestroy</a></li><li><a href="DataStore.html#event:afterDestroyAll">DataStore#event:afterDestroyAll</a></li><li><a href="DataStore.html#event:afterFind">DataStore#event:afterFind</a></li><li><a href="DataStore.html#event:afterFindAll">DataStore#event:afterFindAll</a></li><li><a href="DataStore.html#event:afterUpdate">DataStore#event:afterUpdate</a></li><li><a href="DataStore.html#event:afterUpdateAll">DataStore#event:afterUpdateAll</a></li><li><a href="DataStore.html#event:afterUpdateMany">DataStore#event:afterUpdateMany</a></li><li><a href="DataStore.html#event:beforeCreate">DataStore#event:beforeCreate</a></li><li><a href="DataStore.html#event:beforeCreateMany">DataStore#event:beforeCreateMany</a></li><li><a href="DataStore.html#event:beforeDestroy">DataStore#event:beforeDestroy</a></li><li><a href="DataStore.html#event:beforeDestroyAll">DataStore#event:beforeDestroyAll</a></li><li><a href="DataStore.html#event:beforeFind">DataStore#event:beforeFind</a></li><li><a href="DataStore.html#event:beforeFindAll">DataStore#event:beforeFindAll</a></li><li><a href="DataStore.html#event:beforeUpdate">DataStore#event:beforeUpdate</a></li><li><a href="DataStore.html#event:beforeUpdateAll">DataStore#event:beforeUpdateAll</a></li><li><a href="DataStore.html#event:beforeUpdateMany">DataStore#event:beforeUpdateMany</a></li><li><a href="DataStore.html#event:change">DataStore#event:change</a></li><li><a href="DataStore.html#event:remove">DataStore#event:remove</a></li><li><a href="LinkedCollection.html#event:add">LinkedCollection#event:add</a></li><li><a href="LinkedCollection.html#event:change">LinkedCollection#event:change</a></li><li><a href="LinkedCollection.html#event:remove">LinkedCollection#event:remove</a></li><li><a href="Mapper.html#event:afterCreate">Mapper#event:afterCreate</a></li><li><a href="Mapper.html#event:afterCreateMany">Mapper#event:afterCreateMany</a></li><li><a href="Mapper.html#event:afterDestroy">Mapper#event:afterDestroy</a></li><li><a href="Mapper.html#event:afterDestroyAll">Mapper#event:afterDestroyAll</a></li><li><a href="Mapper.html#event:afterFind">Mapper#event:afterFind</a></li><li><a href="Mapper.html#event:afterFindAll">Mapper#event:afterFindAll</a></li><li><a href="Mapper.html#event:afterUpdate">Mapper#event:afterUpdate</a></li><li><a href="Mapper.html#event:afterUpdateAll">Mapper#event:afterUpdateAll</a></li><li><a href="Mapper.html#event:afterUpdateMany">Mapper#event:afterUpdateMany</a></li><li><a href="Mapper.html#event:beforeCreate">Mapper#event:beforeCreate</a></li><li><a href="Mapper.html#event:beforeCreateMany">Mapper#event:beforeCreateMany</a></li><li><a href="Mapper.html#event:beforeDestroy">Mapper#event:beforeDestroy</a></li><li><a href="Mapper.html#event:beforeDestroyAll">Mapper#event:beforeDestroyAll</a></li><li><a href="Mapper.html#event:beforeFind">Mapper#event:beforeFind</a></li><li><a href="Mapper.html#event:beforeFindAll">Mapper#event:beforeFindAll</a></li><li><a href="Mapper.html#event:beforeUpdate">Mapper#event:beforeUpdate</a></li><li><a href="Mapper.html#event:beforeUpdateAll">Mapper#event:beforeUpdateAll</a></li><li><a href="Mapper.html#event:beforeUpdateMany">Mapper#event:beforeUpdateMany</a></li><li><a href="Record.html#event:change">Record#event:change</a></li><li><a href="SimpleStore.html#event:add">SimpleStore#event:add</a></li><li><a href="SimpleStore.html#event:afterCreate">SimpleStore#event:afterCreate</a></li><li><a href="SimpleStore.html#event:afterCreateMany">SimpleStore#event:afterCreateMany</a></li><li><a href="SimpleStore.html#event:afterDestroy">SimpleStore#event:afterDestroy</a></li><li><a href="SimpleStore.html#event:afterDestroyAll">SimpleStore#event:afterDestroyAll</a></li><li><a href="SimpleStore.html#event:afterFind">SimpleStore#event:afterFind</a></li><li><a href="SimpleStore.html#event:afterFindAll">SimpleStore#event:afterFindAll</a></li><li><a href="SimpleStore.html#event:afterUpdate">SimpleStore#event:afterUpdate</a></li><li><a href="SimpleStore.html#event:afterUpdateAll">SimpleStore#event:afterUpdateAll</a></li><li><a href="SimpleStore.html#event:afterUpdateMany">SimpleStore#event:afterUpdateMany</a></li><li><a href="SimpleStore.html#event:beforeCreate">SimpleStore#event:beforeCreate</a></li><li><a href="SimpleStore.html#event:beforeCreateMany">SimpleStore#event:beforeCreateMany</a></li><li><a href="SimpleStore.html#event:beforeDestroy">SimpleStore#event:beforeDestroy</a></li><li><a href="SimpleStore.html#event:beforeDestroyAll">SimpleStore#event:beforeDestroyAll</a></li><li><a href="SimpleStore.html#event:beforeFind">SimpleStore#event:beforeFind</a></li><li><a href="SimpleStore.html#event:beforeFindAll">SimpleStore#event:beforeFindAll</a></li><li><a href="SimpleStore.html#event:beforeUpdate">SimpleStore#event:beforeUpdate</a></li><li><a href="SimpleStore.html#event:beforeUpdateAll">SimpleStore#event:beforeUpdateAll</a></li><li><a href="SimpleStore.html#event:beforeUpdateMany">SimpleStore#event:beforeUpdateMany</a></li><li><a href="SimpleStore.html#event:change">SimpleStore#event:change</a></li><li><a href="SimpleStore.html#event:remove">SimpleStore#event:remove</a></li>
				</ul>
			</li>
			
		</ul>
	</div>

</div>
</div>


<div style="padding: 1%" id="toc-content">
<div class="row">

	

	<!-- <div class="clearfix"></div> -->

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: Record.js</h1>
    
<section>
    <article>
        <pre><code
            class="javascript linenums">import utils, { safeSetLink } from './utils'
import Component from './Component'
import Settable from './Settable'
import {
  hasManyType,
  hasOneType
} from './decorators'

const DOMAIN = 'Record'

const superMethod = function (mapper, name) {
  const store = mapper.datastore
  if (store &amp;&amp; store[name]) {
    return function (...args) {
      return store[name](mapper.name, ...args)
    }
  }
  return mapper[name].bind(mapper)
}

// Cache these strings
const creatingPath = 'creating'
const noValidatePath = 'noValidate'
const keepChangeHistoryPath = 'keepChangeHistory'
const previousPath = 'previous'

/**
 * js-data's Record class. An instance of `Record` corresponds to an in-memory
 * representation of a single row or document in a database, Firebase,
 * localstorage, etc. Basically, a `Record` instance represents whatever kind of
 * entity in your persistence layer that has a primary key.
 *
 * ```javascript
 * import {Record} from 'js-data'
 * ```
 *
 * @example &lt;caption>Record#constructor&lt;/caption>
 * // Normally you would do: import {Record} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Record} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * // Instantiate a plain record
 * let record = new Record()
 * console.log('record: ' + JSON.stringify(record))
 *
 * // You can supply properties on instantiation
 * record = new Record({ name: 'John' })
 * console.log('record: ' + JSON.stringify(record))
 *
 * @example &lt;caption>Record#constructor2&lt;/caption>
 * // Normally you would do: import {Mapper} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Mapper} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * // Instantiate a record that's associated with a Mapper:
 * const UserMapper = new Mapper({ name: 'user' })
 * const User = UserMapper.recordClass
 * const user = UserMapper.createRecord({ name: 'John' })
 * const user2 = new User({ name: 'Sally' })
 * console.log('user: ' + JSON.stringify(user))
 * console.log('user2: ' + JSON.stringify(user2))
 *
 * @example &lt;caption>Record#constructor3&lt;/caption>
 * // Normally you would do: import {Container} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Container} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * const store = new Container()
 * store.defineMapper('user')
 *
 * // Instantiate a record that's associated with a store's Mapper
 * const user = store.createRecord('user', { name: 'John' })
 * console.log('user: ' + JSON.stringify(user))
 *
 * @example &lt;caption>Record#constructor4&lt;/caption>
 * // Normally you would do: import {Container} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Container} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * const store = new Container()
 * store.defineMapper('user', {
 *   schema: {
 *     properties: {
 *       name: { type: 'string' }
 *     }
 *   }
 * })
 *
 * // Validate on instantiation
 * const user = store.createRecord('user', { name: 1234 })
 * console.log('user: ' + JSON.stringify(user))
 *
 * @example &lt;caption>Record#constructor5&lt;/caption>
 * // Normally you would do: import {Container} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Container} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * const store = new Container()
 * store.defineMapper('user', {
 *   schema: {
 *     properties: {
 *       name: { type: 'string' }
 *     }
 *   }
 * })
 *
 * // Skip validation on instantiation
 * const user = store.createRecord('user', { name: 1234 }, { noValidate: true })
 * console.log('user: ' + JSON.stringify(user))
 * console.log('user.isValid(): ' + user.isValid())
 *
 * @class Record
 * @extends Component
 * @param {Object} [props] The initial properties of the new Record instance.
 * @param {Object} [opts] Configuration options.
 * @param {boolean} [opts.noValidate=false] Whether to skip validation on the
 * initial properties.
 * @param {boolean} [opts.validateOnSet=true] Whether to enable setter
 * validation on properties after the Record has been initialized.
 * @since 3.0.0
 */
function Record (props, opts) {
  utils.classCallCheck(this, Record)
  Settable.call(this)
  props || (props = {})
  opts || (opts = {})
  const _set = this._set
  _set(creatingPath, true)
  _set(noValidatePath, !!opts.noValidate)
  _set(keepChangeHistoryPath, opts.keepChangeHistory === undefined ? (mapper ? mapper.keepChangeHistory : true) : opts.keepChangeHistory)

  // Set the idAttribute value first, if it exists.
  const mapper = this.constructor.mapper
  const id = mapper ? utils.get(props, mapper.idAttribute) : undefined
  if (id !== undefined) {
    utils.set(this, mapper.idAttribute, id)
  }

  utils.fillIn(this, props)
  _set(creatingPath, false)
  if (opts.validateOnSet !== undefined) {
    _set(noValidatePath, !opts.validateOnSet)
  } else if (mapper &amp;&amp; mapper.validateOnSet !== undefined) {
    _set(noValidatePath, !mapper.validateOnSet)
  } else {
    _set(noValidatePath, false)
  }
  _set(previousPath, mapper ? mapper.toJSON(props) : utils.plainCopy(props))
}

export default Component.extend({
  constructor: Record,

  /**
   * Returns the {@link Mapper} paired with this record's class, if any.
   *
   * @method Record#_mapper
   * @returns {Mapper} The {@link Mapper} paired with this record's class, if any.
   * @since 3.0.0
   */
  _mapper () {
    const mapper = this.constructor.mapper
    if (!mapper) {
      throw utils.err(`${DOMAIN}#_mapper`, '')(404, 'mapper')
    }
    return mapper
  },

  /**
   * Lifecycle hook.
   *
   * @method Record#afterLoadRelations
   * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}.
   * @param {Object} opts The `opts` argument passed to {@link Record#loadRelations}.
   * @since 3.0.0
   */
  afterLoadRelations () {},

  /**
   * Lifecycle hook.
   *
   * @method Record#beforeLoadRelations
   * @param {string[]} relations The `relations` argument passed to {@link Record#loadRelations}.
   * @param {Object} opts The `opts` argument passed to {@link Record#loadRelations}.
   * @since 3.0.0
   */
  beforeLoadRelations () {},

  /**
   * Return the change history of this record since it was instantiated or
   * {@link Record#commit} was called.
   *
   * @method Record#changeHistory
   * @since 3.0.0
   */
  changeHistory () {
    return (this._get('history') || []).slice()
  },

  /**
   * Return changes to this record since it was instantiated or
   * {@link Record#commit} was called.
   *
   * @example &lt;caption>Record#changes&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   *
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user')
   * console.log('user changes: ' + JSON.stringify(user.changes()))
   * user.name = 'John'
   * console.log('user changes: ' + JSON.stringify(user.changes()))
   *
   * @method Record#changes
   * @param [opts] Configuration options.
   * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function.
   * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore.
   * @returns {Object} Object describing the changes to this record since it was
   * instantiated or its {@link Record#commit} method was last called.
   * @since 3.0.0
   */
  changes (opts) {
    opts || (opts = {})
    return utils.diffObjects(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts)
  },

  /**
   * Make the record's current in-memory state it's only state, with any
   * previous property values being set to current values.
   *
   * @example &lt;caption>Record#commit&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   *
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user')
   * console.log('user hasChanges: ' + user.hasChanges())
   * user.name = 'John'
   * console.log('user hasChanges: ' + user.hasChanges())
   * user.commit()
   * console.log('user hasChanges: ' + user.hasChanges())
   *
   * @method Record#commit
   * @param {Object} [opts] Configuration options. Passed to {@link Record#toJSON}.
   * @since 3.0.0
   */
  commit (opts) {
    this._set('changed') // unset
    this._set('history', []) // clear history
    this._set('previous', this.toJSON(opts))
  },

  /**
   * Call {@link Mapper#destroy} using this record's primary key.
   *
   * @example
   * import {Container} from 'js-data'
   * import {RethinkDBAdapter} from 'js-data-rethinkdb'
   *
   * const store = new Container()
   * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true })
   * store.defineMapper('user')
   * store.find('user', 1234).then((user) => {
   *   console.log(user.id) // 1234
   *
   *   // Destroy this user from the database
   *   return user.destroy()
   * })
   *
   * @method Record#destroy
   * @param {Object} [opts] Configuration options passed to {@link Mapper#destroy}.
   * @returns {Promise} The result of calling {@link Mapper#destroy} with the
   * primary key of this record.
   * @since 3.0.0
   */
  destroy (opts) {
    opts || (opts = {})
    const mapper = this._mapper()
    return superMethod(mapper, 'destroy')(utils.get(this, mapper.idAttribute), opts)
  },

  /**
   * Return the value at the given path for this instance.
   *
   * @example &lt;caption>Record#get&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   *
   * const user = store.createRecord('user', { name: 'Bob' })
   * console.log('user.get("name"): ' + user.get('name'))
   *
   * @method Record#get
   * @param {string} key Path of value to retrieve.
   * @returns {*} Value at path.
   * @since 3.0.0
   */
  'get' (key) {
    return utils.get(this, key)
  },

  /**
   * Return whether this record has changed since it was instantiated or
   * {@link Record#commit} was called.
   *
   * @example &lt;caption>Record#hasChanges&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user')
   * console.log('user hasChanges: ' + user.hasChanges())
   * user.name = 'John'
   * console.log('user hasChanges: ' + user.hasChanges())
   * user.commit()
   * console.log('user hasChanges: ' + user.hasChanges())
   *
   * @method Record#hasChanges
   * @param [opts] Configuration options.
   * @param {Function} [opts.equalsFn={@link utils.deepEqual}] Equality function.
   * @param {Array} [opts.ignore=[]] Array of strings or RegExp of fields to ignore.
   * @returns {boolean} Return whether the record has changed since it was
   * instantiated or since its {@link Record#commit} method was called.
   * @since 3.0.0
   */
  hasChanges (opts) {
    const quickHasChanges = !!(this._get('changed') || []).length
    return quickHasChanges || utils.areDifferent(typeof this.toJSON === 'function' ? this.toJSON(opts) : this, this._get('previous'), opts)
  },

  /**
   * Return whether the record is unsaved. Records that have primary keys are
   * considered "saved". Records without primary keys are considered "unsaved".
   *
   * @example &lt;caption>Record#isNew&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user', {
   *   id: 1234
   * })
   * const user2 = store.createRecord('user')
   * console.log('user isNew: ' + user.isNew()) // false
   * console.log('user2 isNew: ' + user2.isNew()) // true
   *
   * @method Record#isNew
   * @returns {boolean} Whether the record is unsaved.
   * @since 3.0.0
   */
  isNew (opts) {
    return utils.get(this, this._mapper().idAttribute) === undefined
  },

  /**
   * Return whether the record in its current state passes validation.
   *
   * @example &lt;caption>Record#isValid&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user', {
   *   schema: {
   *     properties: {
   *       name: { type: 'string' }
   *     }
   *   }
   * })
   * const user = store.createRecord('user', {
   *   name: 1234
   * }, {
   *   noValidate: true // this allows us to put the record into an invalid state
   * })
   * console.log('user isValid: ' + user.isValid())
   * user.name = 'John'
   * console.log('user isValid: ' + user.isValid())
   *
   * @method Record#isValid
   * @param {Object} [opts] Configuration options. Passed to {@link Mapper#validate}.
   * @returns {boolean} Whether the record in its current state passes
   * validation.
   * @since 3.0.0
   */
  isValid (opts) {
    return !this._mapper().validate(this, opts)
  },

  removeInverseRelation (currentParent, id, inverseDef, idAttribute) {
    if (inverseDef.type === hasOneType) {
      safeSetLink(currentParent, inverseDef.localField, undefined)
    } else if (inverseDef.type === hasManyType) {
      // e.g. remove comment from otherPost.comments
      const children = utils.get(currentParent, inverseDef.localField)
      if (id === undefined) {
        utils.remove(children, (child) => child === this)
      } else {
        utils.remove(children, (child) => child === this || id === utils.get(child, idAttribute))
      }
    }
  },

  setupInverseRelation (record, id, inverseDef, idAttribute) {
      // Update (set) inverse relation
    if (inverseDef.type === hasOneType) {
      // e.g. someUser.profile = profile
      safeSetLink(record, inverseDef.localField, this)
    } else if (inverseDef.type === hasManyType) {
      // e.g. add comment to somePost.comments
      const children = utils.get(record, inverseDef.localField)
      if (id === undefined) {
        utils.noDupeAdd(children, this, (child) => child === this)
      } else {
        utils.noDupeAdd(children, this, (child) => child === this || id === utils.get(child, idAttribute))
      }
    }
  },

  /**
   * Lazy load relations of this record, to be attached to the record once their
   * loaded.
   *
   * @example
   * import {Container} from 'js-data'
   * import {RethinkDBAdapter} from 'js-data-rethinkdb'
   *
   * const store = new Container()
   * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true })
   * store.defineMapper('user', {
   *   relations: {
   *     hasMany: {
   *       post: {
   *         localField: 'posts',
   *         foreignKey: 'user_id'
   *       }
   *     }
   *   }
   * })
   * store.defineMapper('post', {
   *   relations: {
   *     belongsTo: {
   *       user: {
   *         localField: 'user',
   *         foreignKey: 'user_id'
   *       }
   *     }
   *   }
   * })
   * store.find('user', 1234).then((user) => {
   *   console.log(user.id) // 1234
   *
   *   // Load the user's post relations
   *   return user.loadRelations(['post'])
   * }).then((user) => {
   *   console.log(user.posts) // [{...}, {...}, ...]
   * })
   *
   * @method Record#loadRelations
   * @param {string[]} [relations] List of relations to load. Can use localField
   * names or Mapper names to pick relations.
   * @param {Object} [opts] Configuration options.
   * @returns {Promise} Resolves with the record, with the loaded relations now
   * attached.
   * @since 3.0.0
   */
  loadRelations (relations, opts) {
    let op
    const mapper = this._mapper()

    // Default values for arguments
    relations || (relations = [])
    if (utils.isString(relations)) {
      relations = [relations]
    }
    opts || (opts = {})
    opts.with = relations

    // Fill in "opts" with the Model's configuration
    utils._(opts, mapper)
    opts.adapter = mapper.getAdapterName(opts)

    // beforeLoadRelations lifecycle hook
    op = opts.op = 'beforeLoadRelations'
    return utils.resolve(this[op](relations, opts)).then(() => {
      // Now delegate to the adapter
      op = opts.op = 'loadRelations'
      mapper.dbg(op, this, relations, opts)
      let tasks = []
      let task
      utils.forEachRelation(mapper, opts, (def, optsCopy) => {
        const relatedMapper = def.getRelation()
        optsCopy.raw = false
        if (utils.isFunction(def.load)) {
          task = def.load(mapper, def, this, opts)
        } else if (def.type === 'hasMany' || def.type === 'hasOne') {
          if (def.foreignKey) {
            task = superMethod(relatedMapper, 'findAll')({
              [def.foreignKey]: utils.get(this, mapper.idAttribute)
            }, optsCopy).then(function (relatedData) {
              if (def.type === 'hasOne') {
                return relatedData.length ? relatedData[0] : undefined
              }
              return relatedData
            })
          } else if (def.localKeys) {
            task = superMethod(relatedMapper, 'findAll')({
              where: {
                [relatedMapper.idAttribute]: {
                  'in': utils.get(this, def.localKeys)
                }
              }
            })
          } else if (def.foreignKeys) {
            task = superMethod(relatedMapper, 'findAll')({
              where: {
                [def.foreignKeys]: {
                  'contains': utils.get(this, mapper.idAttribute)
                }
              }
            }, opts)
          }
        } else if (def.type === 'belongsTo') {
          const key = utils.get(this, def.foreignKey)
          if (utils.isSorN(key)) {
            task = superMethod(relatedMapper, 'find')(key, optsCopy)
          }
        }
        if (task) {
          task = task.then((relatedData) => {
            def.setLocalField(this, relatedData)
          })
          tasks.push(task)
        }
      })
      return Promise.all(tasks)
    }).then(() => {
      // afterLoadRelations lifecycle hook
      op = opts.op = 'afterLoadRelations'
      return utils.resolve(this[op](relations, opts)).then(() => this)
    })
  },

  /**
   * Return the properties with which this record was instantiated.
   *
   * @example &lt;caption>Record#previous&lt;/caption>
   * // import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user', {
   *   name: 'William'
   * })
   * console.log('user previous: ' + JSON.stringify(user.previous()))
   * user.name = 'Bob'
   * console.log('user previous: ' + JSON.stringify(user.previous()))
   * user.commit()
   * console.log('user previous: ' + JSON.stringify(user.previous()))
   *
   * @method Record#previous
   * @param {string} [key] If specified, return just the initial value of the
   * given key.
   * @returns {Object} The initial properties of this record.
   * @since 3.0.0
   */
  previous (key) {
    if (key) {
      return this._get(`previous.${key}`)
    }
    return this._get('previous')
  },

  /**
   * Revert changes to this record back to the properties it had when it was
   * instantiated.
   *
   * @example &lt;caption>Record#revert&lt;/caption>
   * // import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   * const user = store.createRecord('user', {
   *   name: 'William'
   * })
   * console.log('user: ' + JSON.stringify(user))
   * user.name = 'Bob'
   * console.log('user: ' + JSON.stringify(user))
   * user.revert()
   * console.log('user: ' + JSON.stringify(user))
   *
   * @method Record#revert
   * @param {Object} [opts] Configuration options.
   * @param {string[]} [opts.preserve] Array of strings or Regular Expressions
   * denoting properties that should not be reverted.
   * @since 3.0.0
   */
  revert (opts) {
    const previous = this._get('previous')
    opts || (opts = {})
    opts.preserve || (opts.preserve = [])
    utils.forOwn(this, (value, key) => {
      if (key !== this._mapper().idAttribute &amp;&amp; !previous.hasOwnProperty(key) &amp;&amp; this.hasOwnProperty(key) &amp;&amp; opts.preserve.indexOf(key) === -1) {
        delete this[key]
      }
    })
    utils.forOwn(previous, (value, key) => {
      if (opts.preserve.indexOf(key) === -1) {
        this[key] = value
      }
    })
    this.commit()
  },

  /**
   * Delegates to {@link Mapper#create} or {@link Mapper#update}.
   *
   * @example
   * import {Container} from 'js-data'
   * import {RethinkDBAdapter} from 'js-data-rethinkdb'
   *
   * const store = new Container()
   * store.registerAdapter('rethink', new RethinkDBAdapter(), { default: true })
   * store.defineMapper('session')
   * const session = store.createRecord('session', { topic: 'Node.js' })
   *
   * // Create a new record in the database
   * session.save().then(() => {
   *   console.log(session.id) // 1234
   *
   *   session.skill_level = 'beginner'
   *
   *   // Update the record in the database
   *   return session.save()
   * })
   *
   * @method Record#save
   * @param {Object} [opts] Configuration options. See {@link Mapper#create} and
   * {@link Mapper#update}.
   * @param {boolean} [opts.changesOnly] Equality function. Default uses `===`.
   * @param {Function} [opts.equalsFn] Passed to {@link Record#changes} when
   * `opts.changesOnly` is `true`.
   * @param {Array} [opts.ignore] Passed to {@link Record#changes} when
   * `opts.changesOnly` is `true`.
   * @returns {Promise} The result of calling {@link Mapper#create} or
   * {@link Mapper#update}.
   * @since 3.0.0
   */
  save (opts) {
    opts || (opts = {})
    const mapper = this._mapper()
    const id = utils.get(this, mapper.idAttribute)
    let props = this

    const postProcess = (result) => {
      const record = opts.raw ? result.data : result
      if (record) {
        utils.deepMixIn(this, record)
        this.commit()
      }
      return result
    }

    if (id === undefined) {
      return superMethod(mapper, 'create')(props, opts).then(postProcess)
    }
    if (opts.changesOnly) {
      const changes = this.changes(opts)
      props = {}
      utils.fillIn(props, changes.added)
      utils.fillIn(props, changes.changed)
    }
    return superMethod(mapper, 'update')(id, props, opts).then(postProcess)
  },

  /**
   * Set the value for a given key, or the values for the given keys if "key" is
   * an object. Triggers change events on those properties that have `track: true`
   * in {@link Mapper#schema}.
   *
   * @example &lt;caption>Record#set&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   *
   * const user = store.createRecord('user')
   * console.log('user: ' + JSON.stringify(user))
   *
   * user.set('name', 'Bob')
   * console.log('user: ' + JSON.stringify(user))
   *
   * user.set({ age: 30, role: 'admin' })
   * console.log('user: ' + JSON.stringify(user))
   *
   * @fires Record#change
   * @method Record#set
   * @param {(string|Object)} key Key to set or hash of key-value pairs to set.
   * @param {*} [value] Value to set for the given key.
   * @param {Object} [opts] Configuration options.
   * @param {boolean} [opts.silent=false] Whether to trigger change events.
   * @since 3.0.0
   */
  'set' (key, value, opts) {
    if (utils.isObject(key)) {
      opts = value
    }
    opts || (opts = {})
    if (opts.silent) {
      this._set('silent', true)
    }
    utils.set(this, key, value)
    if (!this._get('eventId')) {
      this._set('silent') // unset
    }
  },

  /**
   * Return a plain object representation of this record. If the class from
   * which this record was created has a Mapper, then {@link Mapper#toJSON} will
   * be called with this record instead.
   *
   * @example &lt;caption>Record#toJSON&lt;/caption>
   * // Normally you would do: import { Container } from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.8')
   * const { Container } = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user', {
   *   schema: {
   *     properties: {
   *       name: { type: 'string' }
   *     }
   *   }
   * })
   *
   * const user = store.createRecord('user', {
   *   name: 'John',
   *   $$hashKey: '1234'
   * })
   * console.log('user: ' + JSON.stringify(user.toJSON()))
   *
   * @method Record#toJSON
   * @param {Object} [opts] Configuration options.
   * @param {string[]} [opts.with] Array of relation names or relation fields
   * to include in the representation. Only available as an option if the class
   * from which this record was created has a Mapper and this record resides in
   * an instance of {@link DataStore}.
   * @returns {Object} Plain object representation of this record.
   * @since 3.0.0
   */
  toJSON (opts) {
    const mapper = this.constructor.mapper
    if (mapper) {
      return mapper.toJSON(this, opts)
    } else {
      const json = {}
      utils.forOwn(this, (prop, key) => {
        json[key] = utils.plainCopy(prop)
      })
      return json
    }
  },

  /**
   * Unset the value for a given key. Triggers change events on those properties
   * that have `track: true` in {@link Mapper#schema}.
   *
   * @example &lt;caption>Record#unset&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user')
   *
   * const user = store.createRecord('user', {
   *   name: 'John'
   * })
   * console.log('user: ' + JSON.stringify(user))
   *
   * user.unset('name')
   * console.log('user: ' + JSON.stringify(user))
   *
   * @method Record#unset
   * @param {string} key Key to unset.
   * @param {Object} [opts] Configuration options.
   * @param {boolean} [opts.silent=false] Whether to trigger change events.
   * @since 3.0.0
   */
  unset (key, opts) {
    this.set(key, undefined, opts)
  },

  /**
   * Validate this record based on its current properties.
   *
   * @example &lt;caption>Record#validate&lt;/caption>
   * // Normally you would do: import {Container} from 'js-data'
   * const JSData = require('js-data@3.0.0-rc.4')
   * const {Container} = JSData
   * console.log('Using JSData v' + JSData.version.full)
   * const store = new Container()
   * store.defineMapper('user', {
   *   schema: {
   *     properties: {
   *       name: { type: 'string' }
   *     }
   *   }
   * })
   * const user = store.createRecord('user', {
   *   name: 1234
   * }, {
   *   noValidate: true // this allows us to put the record into an invalid state
   * })
   * console.log('user validation: ' + JSON.stringify(user.validate()))
   * user.name = 'John'
   * console.log('user validation: ' + user.validate())
   *
   * @method Record#validate
   * @param {Object} [opts] Configuration options. Passed to {@link Mapper#validate}.
   * @returns {*} Array of errors or `undefined` if no errors.
   * @since 3.0.0
   */
  validate (opts) {
    return this._mapper().validate(this, opts)
  }
}, {
  creatingPath,
  noValidatePath,
  keepChangeHistoryPath,
  previousPath
})

/**
 * Allow records to emit events.
 *
 * An record's registered listeners are stored in the record's private data.
 */
utils.eventify(
  Record.prototype,
  function () {
    return this._get('events')
  },
  function (value) {
    this._set('events', value)
  }
)

/**
 * Fired when a record changes. Only works for records that have tracked fields.
 * See {@link Record~changeListener} on how to listen for this event.
 *
 * @event Record#change
 * @see Record~changeListener
 */

/**
 * Callback signature for the {@link Record#event:change} event.
 *
 * @example
 * function onChange (record, changes) {
 *   // do something
 * }
 * record.on('change', onChange)
 *
 * @callback Record~changeListener
 * @param {Record} The Record that changed.
 * @param {Object} The changes.
 * @see Record#event:change
 * @since 3.0.0
 */

/**
 * Create a subclass of this Record:
 * @example &lt;caption>Record.extend&lt;/caption>
 * // Normally you would do: import {Record} from 'js-data'
 * const JSData = require('js-data@3.0.0-rc.4')
 * const {Record} = JSData
 * console.log('Using JSData v' + JSData.version.full)
 *
 * // Extend the class using ES2015 class syntax.
 * class CustomRecordClass extends Record {
 *   foo () { return 'bar' }
 *   static beep () { return 'boop' }
 * }
 * const customRecord = new CustomRecordClass()
 * console.log(customRecord.foo())
 * console.log(CustomRecordClass.beep())
 *
 * // Extend the class using alternate method.
 * const OtherRecordClass = Record.extend({
 *   foo () { return 'bar' }
 * }, {
 *   beep () { return 'boop' }
 * })
 * const otherRecord = new OtherRecordClass()
 * console.log(otherRecord.foo())
 * console.log(OtherRecordClass.beep())
 *
 * // Extend the class, providing a custom constructor.
 * function AnotherRecordClass () {
 *   Record.call(this)
 *   this.created_at = new Date().getTime()
 * }
 * Record.extend({
 *   constructor: AnotherRecordClass,
 *   foo () { return 'bar' }
 * }, {
 *   beep () { return 'boop' }
 * })
 * const anotherRecord = new AnotherRecordClass()
 * console.log(anotherRecord.created_at)
 * console.log(anotherRecord.foo())
 * console.log(AnotherRecordClass.beep())
 *
 * @method Record.extend
 * @param {Object} [props={}] Properties to add to the prototype of the
 * subclass.
 * @param {Object} [props.constructor] Provide a custom constructor function
 * to be used as the subclass itself.
 * @param {Object} [classProps={}] Static properties to add to the subclass.
 * @returns {Constructor} Subclass of this Record class.
 * @since 3.0.0
 */
</code></pre>
    </article>
</section>





		</div>
	</div>

</div>
</div>

<div class="modal fade" id="searchResults">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Search results</h4>
      </div>
      <div class="modal-body"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div>

<footer>

	<div style="text-align:center"><a href="/">api.js-data.io</a>&nbsp;&#8226;&nbsp;<a href="http://js-data.io">js-data.io</a></div>


	<span class="copyright">
	js-data Copyright Â© 2014-2016 js-data project authors
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on 2017-02-21T12:26:55-08:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>
<!-- <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script> -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/languages/javascript.min.js"></script>

<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	hljs.initHighlightingOnLoad();

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			var id = $( heading ).attr( "id" );
			return id && id.replace(/\~/g, '-inner-').replace(/\./g, '-static-') || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true,
    highlightOnScroll: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->

<script>
	(function ( i, s, o, g, r, a, m ) {
		i['GoogleAnalyticsObject'] = r;
		i[r] = i[r] || function () {
			(i[r].q = i[r].q || []).push( arguments )
		}, i[r].l = 1 * new Date();
		a = s.createElement( o ),
			m = s.getElementsByTagName( o )[0];
		a.async = 1;
		a.src = g;
		m.parentNode.insertBefore( a, m )
	})( window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga' );

	ga( 'create', 'UA-55528236-2', 'api.js-data.io' );
	ga( 'send', 'pageview' );
</script>


<script src="https://embed.tonicdev.com"></script>
<script>
  window.loadTonic = function (id) {
    var btn = document.getElementById('btn-' + id);
    $(btn).hide();
    var pre = document.getElementById('pre-' + id);
    $(pre).hide();
    var el = document.getElementById('tonic-' + id);
    var $el = $(el);
    var html = $el.html();
    $el.empty();
    $el.show();
    console.log(html);
    Tonic.createNotebook({
      element: el,
      source: html
    });
  };
</script>

</body>
</html>
